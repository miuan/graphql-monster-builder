import { StructureBackend, SchemaModel, SchemaModelRelationType, SchemaModelType } from '../../common/types'
import { writeToFile, templateToText, templateFileToText } from '../../common/files'
import { getOnlyOneRelatedMember, firstToLower } from '../../common/utils'
import { BackendDirectory } from '../backendDirectory'
import { model } from 'mongoose'

export const generateEntry = async (backendDirectory: BackendDirectory, models: SchemaModel[]) => {
    const body = generateEntryWorker(backendDirectory.structure, models)
    backendDirectory.genWrite(`entry`, body)
}

const genAddingAndRemovingsForModel = (model: SchemaModel) => {
    let result = ''
    for (const member of model.members) {
        const relatedMember = member.relation && getOnlyOneRelatedMember(member)

        if (member.relation && relatedMember) {
            const lower = firstToLower(relatedMember.modelName)
            const relationName = member.relation.name
            const funcAddToName = `addTo${relationName}`
            const funcRemoveFromName = `removeFrom${relationName}`

            result += `\t\t${funcAddToName}: entry.resolvers['${lower}'].${funcAddToName},\n`
            result += `\t\t${funcRemoveFromName}: entry.resolvers['${lower}'].${funcRemoveFromName},\n`
        }
    }
    return result
}

export const generateEntryWorker = (structure: StructureBackend, models: SchemaModel[]): string => {
    let body = ''
    let modelsBody = ''
    let services = ''
    let resolvers = ''

    for (const model of structure.models.modules) {
        const lower = model.charAt(0).toLowerCase() + model.slice(1)
        const modelName = `${lower}Model`
        body += `import { ${modelName} } from './models/${model}'\n`
        modelsBody += `entry.models['${lower}'] = ${modelName}\n`
    }
    body += '\n'

    for (const model of structure.services.modules) {
        const lower = model.charAt(0).toLowerCase() + model.slice(1)
        const modelName = `${lower}Service`
        body += `import { generate${model}Service } from './services/${model}'\n`
        services += `entry.services['${lower}'] = generate${model}Service(entry)\n`
    }
    body += '\n'

    for (const model of structure.resolvers.modules) {
        const lower = model.charAt(0).toLowerCase() + model.slice(1)
        const modelName = `${lower}Service`
        body += `import { generate${model}Resolver } from './resolvers/${model}'\n`
        resolvers += `entry.resolvers['${lower}'] = generate${model}Resolver(entry)\n`
    }

    const resolver = createResolvers(structure, models)

    body += templateFileToText('entry.tmpl.ts', {
        _MODELS_BODY_: modelsBody,
        _SERVICES_: services,
        _RE1SOLVERS_: resolvers,
        _RESOLVER_: resolver,
    })

    return body
}

export const createResolvers = (structure: StructureBackend, models: SchemaModel[]) => {
    let queries = ''
    let mutations = ''
    let dataloaders = ''

    for (const model of models) {
        if (model.type === SchemaModelType.MODEL) {
            const modelName = model.modelName
            const lower = modelName.charAt(0).toLowerCase() + modelName.slice(1)
            queries += `\t\t${modelName}: entry.resolvers['${lower}'].one,\n`
            queries += `\t\tall${modelName}: entry.resolvers['${lower}'].all,\n`

            if (modelName !== 'User') mutations += `\t\tcreate${modelName}: entry.resolvers['${lower}'].create,\n`
            mutations += `\t\tupdate${modelName}: entry.resolvers['${lower}'].update,\n`
            mutations += `\t\tremove${modelName}: entry.resolvers['${lower}'].remove,\n`

            mutations += genAddingAndRemovingsForModel(model)
        }

        dataloaders += generateDataloadersForResolver(model)
    }

    const body = `
  {
    Query:{
      ${queries}
    },
    Mutation:{
      ${mutations}
      // generated by entry.ts
      login_v1: extras.generateLogin(entry),
      register_v1: extras.generateRegister(entry),
      logout_v1: extras.generateLogout(entry),
      refreshToken_v1: extras.generateRefreshToken(entry),
      changePassword_v1: extras.generateChangePassword(entry),
      forgottenPassword_v1: extras.generateForgottenPassword(entry),
      forgottenPasswordCheck_v1: extras.generateForgottenPasswordCheck(entry),
      forgottenPasswordReset_v1: extras.generateForgottenPasswordReset(entry),
      verifyEmail_v1: extras.generateVerify(entry),
      verifyEmailResend_v1: extras.generateVerifyEmailResend(entry)
    }
    ${dataloaders}
  }
  `

    return body
}

export const createQueryResolvers = (modules) => {}

export const generateDataloadersForResolver = (model: SchemaModel) => {
    let body = `
  ,${model.modelName}Model: {`

    const memberWithRelation = model.members.filter((m) => m.relation)
    for (const member of memberWithRelation) {
        const memberName = member.name
        const memberModelName = member.relation.relatedModel.modelName
        const lower = memberModelName.charAt(0).toLowerCase() + memberModelName.slice(1)
        const many =
            member.relation.type === SchemaModelRelationType.MANY_TO_MANY ||
            member.relation.type === SchemaModelRelationType.MANY_TO_ONE
        body += `\n\t\t${memberName}: async (root, data, ctx) => {
      return await entry.dataloaders['${lower}'](ctx, root.${memberName},${many})
    },`
    }
    body += `
}`
    return body
}
