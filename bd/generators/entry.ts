import { Structure, SchemaModel, SchemaModelRelationType } from '../../common/types';
import { writeToFile } from '../../common/files';


export const generateEntry = async (structure: Structure, models: SchemaModel[]) => {
  const body = generateEntryWorker(structure, models);
  writeToFile(structure.gen, `entry`, body);
};

export const generateEntryWorker = (structure: Structure, models: SchemaModel[]):string => {
  let body = '';
  let modelsBody = '';
  let services = '';
  let resolvers = '';

  for (const model of structure.models.modules) {
    const lower = model.charAt(0).toLowerCase() + model.slice(1);
    const modelName = `${lower}Model`;
    body += `import { ${modelName } } from './models/${model}';\n`;
    modelsBody += `entry.models['${lower}'] = ${modelName};\n`;
  }
  body += '\n';

  for (const model of structure.services.modules) {
    const lower = model.charAt(0).toLowerCase() + model.slice(1);
    const modelName = `${lower}Service`;
    body += `import { generate${model}Service } from './services/${model}';\n`;
    services += `entry.services['${lower}'] = generate${model}Service(entry);\n`;
  }
  body += '\n';

  for (const model of structure.resolvers.modules) {
    const lower = model.charAt(0).toLowerCase() + model.slice(1);
    const modelName = `${lower}Service`;
    body += `import { generate${model}Resolver } from './resolvers/${model}';\n`;
    resolvers += `entry.resolvers['${lower}'] = generate${model}Resolver(entry);\n`;
  }


  const resolver = createResolvers(structure, models);

  body += `
    import { generateDataloaders } from './dataloaders';
    import * as extras from './extras';

    let hooks;

    try {
      hooks = require('../../custom/${structure.id}/hooks.ts').hooks
    } catch( ex ) {
      hooks = {}
      console.log('missing custom/${structure.id}/hooks.ts');
    }

    export const generateResolver = (setting = {}) => {
      const entry = {
        models:{},
        services:{},
        resolvers:{},
        dataloaders:{},
        hooks:{
          services: {},
          resolvers: {}
        },
      };

      if( hooks.services ){
        for( const serviceHookName in hooks.services ) {
          console.log('Register ' + serviceHookName + ' for service');
          entry.hooks.services[serviceHookName] = hooks.services[serviceHookName];
        }
      }
      

      if( hooks.resolvers ){
        for( const serviceHookName in hooks.resolvers ) {
          console.log('Register ' + serviceHookName + ' for resolver');
          entry.hooks.resolvers[serviceHookName] = hooks.resolvers[serviceHookName];
        }
      }
      

      ${modelsBody}
      ${services}
      ${resolvers}
      
      generateDataloaders(entry);

      const resolver = ${resolver}

      return {
        entry,
        resolver,
      };
    };
  
  `;

  return body;
};


export const createResolvers = (structure: Structure, models: SchemaModel[]) => {
  let queries = '';
  let dataloaders = '';

  for (const modul of structure.resolvers.modules) {
    const lower = modul.charAt(0).toLowerCase() + modul.slice(1);
    queries += `\t\t${modul}: entry.resolvers['${lower}'].one,\n`;
    queries += `\t\tall${modul}s: entry.resolvers['${lower}'].all,\n`;
  }

  let mutations = '';

  for (const modul of structure.resolvers.modules) {
    const lower = modul.charAt(0).toLowerCase() + modul.slice(1);
    mutations += `\t\tcreate${modul}: entry.resolvers['${lower}'].create,\n`;
    mutations += `\t\tupdate${modul}: entry.resolvers['${lower}'].update,\n`;
    mutations += `\t\tdelete${modul}: entry.resolvers['${lower}'].remove,\n`;
  }
  
  for (const model of models) {
    dataloaders += generateDataloadersForResolver(model);
  }
  
  const body = `
  {
    Query:{
      ${queries}
      // generated by entry.ts
      login: extras.generateLogin(entry),
    },
    Mutation:{
      ${mutations}
      // generated by entry.ts
      changePassword: extras.generateChangePassword(entry),
    }
    ${dataloaders}
  }
  `;

  return body;
};

export const createQueryResolvers = (modules) => {
  
};


export const generateDataloadersForResolver = (model: SchemaModel) => {
  let body = `
  ,${model.modelName}: {`;

  const memberWithRelation = model.members.filter(m => m.relation);
  for (const member of memberWithRelation) {
    const memberName = member.name;
    const memberModelName = member.relation.relatedModel.modelName;
    const lower = memberModelName.charAt(0).toLowerCase() + memberModelName.slice(1);
    const many = 
        member.relation.type === SchemaModelRelationType.MANY_TO_MANY 
        || member.relation.type === SchemaModelRelationType.MANY_TO_ONE;
    body += `\n\t\t${memberName}: async (root, data, ctx) => {
      return await entry.dataloaders['${lower}'](ctx, root.${memberName},${many});
    },`;
  }
  body += `
}`;
  return body;
};
